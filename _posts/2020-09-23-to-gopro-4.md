---
title: Road to Go pro - Pointer & Functions
date: 2020-09-23 00:00:00
featured_image: 'https://storage.googleapis.com/songxue-dev-images/content-images/2020-09-23-road-go-pro-4/feature.jpg'
excerpt: 'Road to Go Pro is a series of short Go (the programming language) tutorials that take you from a beginner to a Pro. In this tutorial, we are going to talk about the flow control, loops and the fmt package in Go.'
---

*A few words before we start.*
*You can find the code used in this tutorial in this [repository](https://github.com/songx23/RoadToGoPro).*  
*Also a special thanks to [Mark Hume-Cook](https://medium.com/@mhumecook) for reviewing this tutorial.*

We talked about flow controls and loops in the last part of the tutorial. In this tutorial, we will cover the last part of the basic knowledge of Go, which are pointers and functions. After that, you are well equipped to start writing scripts or console applications using Go.

## Pointers

<!-- // concept -->
If you have used C or C++, pointer is a familiar concept to you. Whereas, the most popular programming languages like Java, C#, Javascript, Python and etc. don't have an explicit syntax to represent pointers. So I think most of the people, like me, don't know what is a pointer when I first heard of this name.  
In short, pointer holds the underlying memory address of a value. Whoa, hold on, memory address? That sounds so 1980. Why do we need to know the memory addresses of variables? That's a good question but before we explore the reasons, we need to take a quick detour. Let's quickly learn how to declare pointers in this section and how to use them in the next [section](#functions). Once we have covered these basics, it will be easier for you to understand the reasoning and examples below. So hang in there. If you already knew the basics and you can't wait to know why, please jump straight to the [Back to pointers](#back-to-pointers) section.

<!-- // * & operator -->
### Declaring pointers

Whenever we declare a variable in Go, the runtime [Fact check] allocates a segment of memory in the physical RAM. The value of that variable is stored there until it's recycled by the garbage collector.  
Pointers are composite data types. We form a pointer type by adding a `*` in front of the data type it points to. For instance, `*string` represents the type of a pointer which points to a string.
To get the pointer value of an existing variable, we just add a `&` in front of the variable.  

```go
pointer := "I'm a string, not a pointer"
// declare a pointer type
var pointerType *string
pointerType = &pointer
// declare a pointer directly
p := &pointer
fmt.Printf("String: %s\nPointerType: %v\nPointer: %v\n", pointer, pointerType, p)
// output:
//   String: I'm a string, not a pointer
//   PointerType: 0xc000010200
//   Pointer: 0xc000010200
```

We mentioned that we don't need to specify data type when declaring variables in the [previous tutorial](https://medium.com/swlh/road-to-go-pro-types-structures-21e5fedc5fe0). This applies to pointer types as well. In the example above, the type of variable `p` will be inferred as `*string` automatically.  
We can also access or set the stored value via a pointer by using `*` to dereference the pointer.  

```go
fmt.Printf("Dereference pointer: %v\n", *p)
// output:
//    Dereference pointer: I'm a string, not a pointer

*p = "Pretending to be a pointer now."
fmt.Printf("New value set via pointer: %v\n", *p)
fmt.Printf("Variable value changed: %s\n", pointer)
// output:
//    New value set via pointer: Pretending to be a pointer now.
//    Variable value changed: Pretending to be a pointer now.
```

Note that when dealing with pointers, we need to keep `nil` in mind as not like primitive types or composite types, the default value of pointer is `nil`. Therefore, we need to be careful of nil pointer exception, also known as NullPointerException in Java/C#.  

```go
// nil pointer
var nilPointer *int
fmt.Printf("nil pointer: %v\n", *nilPointer)
// output:
//    panic: runtime error: invalid memory address or nil pointer dereference
```

## Functions

<!-- // concept -->

<!-- // function arguments, shorthand like xxx, yyy string -->

<!-- // value receiver & pointer receiver -->

<!-- // interface & implementation -->

## Back to pointers

## What's next?

In the next tutorial, we will talk about packages, modules and how to start a Go project from scratch. Hope you find this tutorial helpful. Stay tuned and I will see you in the next one.

**Please feel free to leave a comment below if you run into any problems or if you need a helping hand. Feedbacks are always welcomed. Thank you for reading!**  
