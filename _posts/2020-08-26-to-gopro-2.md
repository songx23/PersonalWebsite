---
title: Road to Go pro - Part 2 - Types & Structures
date: 2020-08-26 00:00:00
featured_image: 'https://storage.googleapis.com/songxue-dev-images/content-images/2020-08-26-road-go-pro-2/feature.jpg'
excerpt: 'Road to Go Pro is a series of short Go (the programming language) tutorials that take you from a beginner to a Pro. This part is about basic types and data structures.'
---

*Before we start, you can find the code used in this tutorial in this [repository](https://github.com/songx23/RoadToGoPro).*

## Primitive types

Primitive types are the most basic types we use in a programming language. Go has four main primitive types namely boolean, integer, float and string. Let's look into each one of them and see what their values can be. 

### Boolean

Boolean is the simplest primitive type. It has only two possible values, true and false.

```go
// primitive type: boolean
var isGoAwesome bool
isGoAwesome = false  // just kidding!
isGoAwesome = true
fmt.Println(isGoAwesome)
```

### Integer

Go has multiple integer types. We can categorise them into two groups.  
First group is signed integers (normal integers). Depending on the integer size, there are multiple types `int`, `int8`, `int16`, `int32`, `int64`.  
And the other group is unsigned integers, which means integers larger or equal than zero. Similarly, we have `uint`, `uint8`, `uint16`, `uint32`, `uint64`.  
Specifically, type `int` and `uint` are at least 32 bits in size, however, they are different than `int32` and `uint32`. The later has fixed size.  
Normally, if you don't a specific use case, using `int` to present integer is a good choice. If you want to represent byte, then you should use unsigned integer `uint8`. In fact, Go has an alias type for `byte = uint8`.  

```go
// primitive type: integer
var integer int
integer = -10
integer = 10
fmt.Println(integer)

var followerCount uint32
followerCount = 10000
// overflow error
// followerCount = -1000
fmt.Println(followerCount)
```

### Float

Floating numbers are numbers with decimal place. There are two types of floating number in Go, `float32` and `float64`.  
`float32` is 32-bit floating point number and `float64` is 64-bit floating point number.  
*`float32` is the equivalent of `float` type in Java/C# and `float64` is the equivalent of `double` type*

```go
// primitive type: float
var balance float32
balance = 10000.01
fmt.Println(balance)
```

### String

String is a set of characters. There is no types specifically representing characters in Go.  

```go
// primitive type: string
var text string
text = "Go is fun."
fmt.Println(text)
```

### nil

`nil` is a special value in Go, which means zero value. It is the same thing as `null` in other programming languages. For the primitive types mentioned above, their value cannot be `nil`.  
For the primitive types, if we don't assign values to them, they will be assigned to a default value.

|primitive type|default value|
|----|-------------|
|boolean|false|
|integer|0|
|float|0.0|
|string|""|

### Declare variable

In the example code blocks above, you can see how you can declare a variable and assign a value to it. Whereas, there is an easier and more recommended way to do the same thing. When declaring variables, Go can implicitly interpret the type of a variable by the value assigned to it.

```go
// import "reflect"
isGoAwesome := true
fmt.Println(reflect.TypeOf(isGoAwesome)) // output: bool
integer := 100
fmt.Println(reflect.TypeOf(integer)) // output: int
float := 100.1
fmt.Println(reflect.TypeOf(float)) // output: float64
text := "Go is fun"
fmt.Println(reflect.TypeOf(text)) // output: string
```

## Composite types

Composite types are made of other basic or composite types. We use them as an abstract representation of the objects. We will be using composite types a lot in Go when programming applications.  
According to the Go language spec, array, struct, pointer, function, interface, slice, map and channel types are the supported composite types in Go. However, we are not going to cover all of them in this part. They will be introduced when we have a more appropriate context in the future parts.

### Array

An array is a list of elements with a defined size. It can but represented as `[n]T`, where `n` is the size and `T` is the type. In Go, an array can only contain elements  of a single type and its size can not be changed.  
Let's see how we can define an array of string.

```go
// composite type: array
var shoppingList [3]string
shoppingList[0] = "Milk"
shoppingList[1] = "Avocado" //smash it
shoppingList[2] = "Beer"
fmt.Println(shoppingList)
// error if you want to stuff more elements than the array can handle
shoppingList[3] = "out of bounds"

// or declare arrays in a simpler way
simpleShoppingList := [3]string{"Milk", "Avocado", "Beer"}
fmt.Println(simpleShoppingList)

// or make compiler do even more work, in case you don't want to count the size
lazyShoppingList := [...]string{"Milk", "Avocado", "Beer"}
fmt.Println(lazyShoppingList)
```

To access the elements in an array, we will need to specify an index. Yes, Go is like most of the programming languages, the index starts from 0, instead of 1.

```go
// to get avocado from my shopping list, I need to find its index
avocado := shoppingList[1]
// fmt package can do better than this but let's stick with Println for now
fmt.Println("Smash ", avocado, "\n")
```

### Slice

Slice is very similar to array, except that it is dynamically-sized. Its representation is `[]T`, where `T` is the type. Similarly, slice can only contain one type of element. In practical, slice is used way more common than array.  
Let's see how you can declare a slice.

```go
// You can stuff as many kinds of bread as you can imagine in this slice.
bread := []string{"ficelle", "la baguette", "brioche"}
fmt.Println(bread)

// another way to declare slice
makeBread := make([]string, 3)
makeBread[0] = "ficelle"
makeBread[1] = "la baguette"
makeBread[2] = "brioche"
fmt.Println(makeBread)

// creating slice from array/slice
breadArr := [3]string{"ficelle", "la baguette", "brioche"}
breadSlice := breadArr[0:3]
fmt.Println(breadSlice)
```

You can use the `make` function to create a slice with defined initial size. In the example, we made a slice of string with initial length of 3. Of course, you can still append more elements in that slice.  

```go
makeBread = append(makeBread, "new bread")
fmt.Println(makeBread)
```

You can also use `array[i,j]` to create a "slice" from an existing array. It custs from index `i`, which is the starting index and its inclusive, to index `j`, which is the ending index and its exclusive. Let's check some examples to understand this better.

```go
breadSliceExample1 := breadArr[0:2]
fmt.Println(breadSliceExample1) // [ficelle la baguette]
breadSliceExample2 := breadArr[1:3]
fmt.Println(breadSliceExample2) // [la baguette brioche]]
```

### Map

Map is another variant of array, you might know it by other names like dictionary or key value pairs. It has a key, which needs to be unique inside the map and it also has a value of associated with it. The representation of map looks like `[T(key)]T'(value)` where `T(key)` is the type of the key and `T'(value)` is the type of the value. There are no specific limitation on these types but usually the type of the key is a primitive type.  

```go
postcodes := make(map[int]string)
postcodes[3000] = "Melbourne"
postcodes[2000] = "Sydney"
postcodes[6000] = "Perth"
fmt.Println(postcodes)

// declare map inline with values
postcodesInline := map[int]string{
    3000: "Melbourne",
    2000: "Sydney",
    6000: "Perth",
}
fmt.Println(postcodesInline)
```

### Struct

### Interface

## Type conversion & Type assertion

### Conversion

### Assertion

## Value types vs Reference types

### Comparison

## What's next?

In the next part, we will talk about loops and logic flows. Stay tuned and I will see you in the next one.

**Please feel free to leave a comment below if you run into any problems or if you need a helping hand.**  
