---
title: Road to Go pro - Part 2 - Types & Structures
date: 2020-08-26 00:00:00
featured_image: 'https://storage.googleapis.com/songxue-dev-images/content-images/2020-08-26-road-go-pro-2/feature.jpg'
excerpt: 'Road to Go Pro is a series of short Go (the programming language) tutorials that take you from a beginner to a Pro. This part is about basic types and data structures.'
---

*Before we start, you can find the code used in this tutorial in this [repository](https://github.com/songx23/RoadToGoPro).*

## Primitive types

Primitive types are the most basic types we use in a programming language. Go has four main primitive types namely boolean, integer, float and string. Let's look into each one of them and see what their values can be. 

### Boolean

Boolean is the simplest primitive type. It has only two possible values, true and false.

```go
// primitive type: boolean
var isGoAwesome bool
isGoAwesome = false  // just kidding!
isGoAwesome = true
fmt.Println(isGoAwesome)
```

### Integer

Go has multiple integer types. We can categorise them into two groups.  
First group is signed integers (normal integers). Depending on the integer size, there are multiple types `int`, `int8`, `int16`, `int32`, `int64`.  
And the other group is unsigned integers, which means integers larger or equal than zero. Similarly, we have `uint`, `uint8`, `uint16`, `uint32`, `uint64`.  
Specifically, type `int` and `uint` are at least 32 bits in size, however, they are different than `int32` and `uint32`. The later has fixed size.  
Normally, if you don't a specific use case, using `int` to present integer is a good choice. If you want to represent byte, then you should use unsigned integer `uint8`. In fact, Go has an alias type for `byte = uint8`.  

```go
// primitive type: integer
var integer int
integer = -10
integer = 10
fmt.Println(integer)

var followerCount uint32
followerCount = 10000
// overflow error
// followerCount = -1000
fmt.Println(followerCount)
```

### Float

Floating numbers are numbers with decimal place. There are two types of floating number in Go, `float32` and `float64`.  
`float32` is 32-bit floating point number and `float64` is 64-bit floating point number.  
*`float32` is the equivalent of `float` type in Java/C# and `float64` is the equivalent of `double` type*

```go
// primitive type: float
var balance float32
balance = 10000.01
fmt.Println(balance)
```

### String

String is a set of characters. There is no types specifically representing characters in Go.  

```go
// primitive type: string
var text string
text = "Go is fun."
fmt.Println(text)
```

### nil

`nil` is a special value in Go, which means zero value. It is the same thing as `null` in other programming languages. For the primitive types mentioned above, their value cannot be `nil`.  
For the primitive types, if we don't assign values to them, they will be assigned to a default value.

|primitive type|default value|
|----|-------------|
|boolean|false|
|integer|0|
|float|0.0|
|string|""|

### Declare variable

In the example code blocks above, you can see how you can declare a variable and assign a value to it. Whereas, there is an easier and more recommended way to do the same thing. When declaring variables, Go can implicitly interpret the type of a variable by the value assigned to it.

```go
// import "reflect"
isGoAwesome := true
fmt.Println(reflect.TypeOf(isGoAwesome)) // output: bool
integer := 100
fmt.Println(reflect.TypeOf(integer)) // output: int
float := 100.1
fmt.Println(reflect.TypeOf(float)) // output: float64
text := "Go is fun"
fmt.Println(reflect.TypeOf(text)) // output: string
```

## Composite types

Composite types are made of other basic or composite types. We use them as an abstract representation of the objects. We will be using composite types a lot in Go when programming applications.  
According to the Go language spec, array, struct, pointer, function, interface, slice, map and channel types are the supported composite types in Go. However, we are not going to cover all of them in this part. They will be introduced when we have a more appropriate context in the future parts.

### Array

An array is a list of elements with a defined size. It can but represented as `[n]T`, where `n` is the size and `T` is the type. In Go, an array can only contain elements  of a single type and its size can not be changed.  
Let's see how we can define an array of string.

```go
// composite type: array
var shoppingList [3]string
shoppingList[0] = "Milk"
shoppingList[1] = "Avocado" //smash it
shoppingList[2] = "Beer"
fmt.Println(shoppingList)
// error if you want to stuff more elements than the array can handle
shoppingList[3] = "out of bounds"

// or declare arrays in a simpler way
simpleShoppingList := [3]string{"Milk", "Avocado", "Beer"}
fmt.Println(simpleShoppingList)

// or make compiler do even more work, in case you don't want to count the size
lazyShoppingList := [...]string{"Milk", "Avocado", "Beer"}
fmt.Println(lazyShoppingList)
```

To access the elements in an array, we will need to specify an index. Yes, Go is like most of the programming languages, the index starts from 0, instead of 1.

```go
// to get avocado from my shopping list, I need to find its index
avocado := shoppingList[1]
// fmt package can do better than this but let's stick with Println for now
fmt.Println("Smash ", avocado)
```

### Slice

Slice is very similar to array, except that it is dynamically-sized. Its representation is `[]T`, where `T` is the type. Similarly, slice can only contain one type of element. In practical, slice is used way more common than array.  
Let's see how you can declare a slice.

```go
// You can stuff as many kinds of bread as you can imagine in this slice.
bread := []string{"ficelle", "la baguette", "brioche"}
fmt.Println(bread)

// another way to declare slice
makeBread := make([]string, 3)
makeBread[0] = "ficelle"
makeBread[1] = "la baguette"
makeBread[2] = "brioche"
fmt.Println(makeBread)

// creating slice from array/slice
breadArr := [3]string{"ficelle", "la baguette", "brioche"}
breadSlice := breadArr[0:3]
fmt.Println(breadSlice)
```

You can use the `make` function to create a slice with defined initial size. In the example, we made a slice of string with initial length of 3. Of course, you can still append more elements in that slice.  

```go
makeBread = append(makeBread, "new bread")
fmt.Println(makeBread)
```

You can also use `array[i,j]` to create a "slice" from an existing array. It custs from index `i`, which is the starting index and its inclusive, to index `j`, which is the ending index and its exclusive. Let's check some examples to understand this better.

```go
breadSliceExample1 := breadArr[0:2]
fmt.Println(breadSliceExample1) // [ficelle la baguette]
breadSliceExample2 := breadArr[1:3]
fmt.Println(breadSliceExample2) // [la baguette brioche]]
```

### Map

Map is another variant of array, it is a collection of key-value pairs. You might know it by another name, dictionary. In a map, we have keys, they need to be unique inside the map and we also have values associated with keys. The representation of map looks like `[T(key)]T'(value)` where `T(key)` is the type of the key and `T'(value)` is the type of the value. There are no specific limitation on these types but usually the type of the key is a primitive type.  

```go
postcodes := make(map[int]string)
postcodes[3000] = "Melbourne"
postcodes[2000] = "Sydney"
postcodes[6000] = "Perth"
fmt.Println(postcodes)

// declare map inline with values
postcodesInline := map[int]string{
    3000: "Melbourne",
    2000: "Sydney",
    6000: "Perth",
}
fmt.Println(postcodesInline)
```

To access a value in map, you will need the corresponding key.

```go
melbourne := postcodes[3000]
fmt.Println(melbourne) // output: Melbourne
```

However, if the key you requested is not in the map, you will get the default value of that value type. For instance, in this example, you will get an empty string back.

```go
darwin := postcodes[8000]
fmt.Println("darwin is empty string? ", darwin == "") // darwin: empty string
```

When accessing the value using a key, map returns a second parameter, which checks whether the key exists or not. You can use that to safely access map value.

```go
// check key existed or not
darwin, ok := postcodes[8000]
fmt.Println("is key present in map? ", ok)            // output: false
fmt.Println("darwin is empty string? ", darwin == "") // darwin: empty string
```

To add a new key value pair, you can simply inject it like this

```go
postcodes[4000] = "Brisbane"
fmt.Println(postcodes) // should see a new pair in map
```

And to delete a key value pair, you can use `delete` function and pass the map with the key you want to delete.

```go
delete(postcodes, 4000)
fmt.Println(postcodes) // should see 4000:Brisbane is removed from map
```

### Struct

Struct is a typed collection of fields, we use it to group information together to represent objects. You can declare a struct like this:

```go
// The structs should be declared outside of main function
type Owner struct {
    FirstName   string
    LastName    string
    PhoneNumber string
    Email       string
}
type Account struct {
    BSB           int
    AccountNumber int64
    AccountType   string
    Owners        []Owner
}
```

Between `type` and `struct` is the struct name, by convention, we use capital letter for the first character. Inside the struct, we declare a field starting with the name first and then its type next. There is no limit on what types you can use in a struct.  
Now we have declared some structs, let's hydrate them with some data.

```go
// declare an account
var account1 Account
account1.BSB = 123456
account1.AccountNumber = 12345678
account1.AccountType = "Joint Account"
account1.Owners = []Owner {
    {
        FirstName: "Jon",
        LastName: "Snow",
        PhoneNumber: "0400100200",
        Email: "jon.snow@got.com",
    },
    {
        FirstName: "Daenerys",
        LastName: "Stormborn",
        PhoneNumber: "0400300400",
        Email: "mother.of.dragons@got.com",
    },
}
fmt.Printf("%+v\n", account1)

// another way to declare an account inline
account2 := Account {
    BSB: 123456,
    AccountNumber: 12345678,
    AccountType: "Joint Account",
    Owners: []Owner {
        {
            FirstName: "Jon",
            LastName: "Snow",
            PhoneNumber: "0400100200",
            Email: "jon.snow@got.com",
        },
        {
            FirstName: "Daenerys",
            LastName: "Stormborn",
            PhoneNumber: "0400300400",
            Email: "mother.of.dragons@got.com",
        },
    },
}
fmt.Printf("%+v\n", account2)
```

You can access the fields in a struct by calling `.<fieldName>` on a struct. For example, if we want to know the BSB number of the account we declared above, we can simply call `account1.BSB` to get the BSB value back.  
Structs are very useful data structure when we start to write applications.  

### Interface

Interface type specifies a collection of functions. It can hold any values that implement the interface. We will look into functions and interfaces in future parts of the tutorial. Here, let's see how we can declare an interface.

```go
// Interfaces should be declared outside of main function
// declare an interface
type Animal interface {
    // function sets
    Eat() string
}
// implement an interface
type Dog struct {}
func (d Dog) Eat() string {
    return fmt.Sprintf("%s eats meat", d.Name)
}

// Following code should be inside main function
// declare a variable with interface type
var poodle Animal
poodle = Dog{Name: "Bolt"}
fmt.Println(poodle.Eat())
```

These might look a bit alien to you but don't worry, you will understand them soon. What we did was declared an interface called `Animal` and it has a function called `Eat()`. We also declared a struct called `Dog`, it implements the `Animal` interface by having the same function required by the interface. Later, when we declared a variable of `Animal` type, we can assign any type that implements `Animal` interface. Thus, it accepts the `Dog` struct.  
Interface is very useful for developing independent sharable modules. You will dig deeper when touching dependency injection.

## Type conversion & Type assertion

So far, we have covered all most used data types and structures. Let's look at another related topic, type converting and assertion.  

### Conversion

We can convert a type to another if the value makes sense to both types. For example, you can convert int to float or string to int.  
To convert between numbers, you can simply use `type(variable)` syntax. If you try to convert float to int, Go will automatically cut off the value after decimal point.   

```Go
convertInt := 1
convertFloat := float32(convertInt)
fmt.Println(convertFloat, reflect.TypeOf(convertFloat))
convertAnotherFloat := 1.8
convertInt = int(convertAnotherFloat)
fmt.Println(convertInt, reflect.TypeOf(convertInt))
```

Fro conversions related to strings, we can use a built-in module called `strconv`. It's quite powerful and covers most of the types.  

```go
// need to import "strconv"
// parse string to boolean
convertBool, err := strconv.ParseBool("true")
fmt.Println(convertBool, reflect.TypeOf(convertBool)) // output: true bool
// convert string to int
strConvertInt, err := strconv.Atoi("-42")
fmt.Println(strConvertInt, reflect.TypeOf(strConvertInt)) // output: -42 int
```

Functions in `strconv` also returns an error. It is handy for error handling and prevents the application from panic errors.

### Assertion

Type assertion provides access to interface value's underlying concrete value. Let's go back to the `Animal` interface example we used before. Assume that `Dog` struct has a special function called `Bark()`.

```go
func (d Dog) Bark() string {
    return fmt.Sprintf("%s: Woff woff!", d.Name)
}
```

When we assigned the Dog concrete value to the variable `poodle`, due to its type is `Animal` interface, we can't access its special functions. To solve this problem, we need to use type assertion to assert the type of underlying value.

```go
// Type assertion
// poodle.Bark() // undefined error
p, ok := poodle.(Dog)
fmt.Println(ok, p.Bark()) // output: true Bolt: Woff woff!
```

Similarly, type assertion returns two variables as well, one of them is the concrete value and the other one is an indicator of whether the assertion is okay or not. After asserting type of `poodle`, we can only access its special function `Bark`.

## Value types vs Reference types

Before we wrap up with data type and structures, I want to point out two more concepts, value types and reference types. Primitive types are value types, when we copy a variable of primitive types, we actually copy their values. In other words, changing the value of a copy doesn't affect the original variable.

```go
valueType := "value"
valueTypeCopy := valueType
valueType = "value changed"
fmt.Println(valueType) // output: value
fmt.Println(valueTypeCopy) // output: value changed
```

On the other hand, composite types are reference types, except for array. When we copy a variable of composite types, we copy their underlying memory address. In other words, changing the value of a copy does affect the original variable.

```go
referenceType := []string{"dog", "cat"}
referenceTypeCopy := referenceType
referenceTypeCopy[1] = "fish"
fmt.Println(referenceType)     // output: dog fish
fmt.Println(referenceTypeCopy) // output: dog fish
```

### Comparison

Distinguishing value types and reference types are valuable when we need to compare two variables. Value type can be compared directly whereas comparison between reference types are more complicated. Most of the complex types can not be compared directly using `==`. However, if you have a simple struct with only primitive types like `Dog`, you can still compare them and getting expected results.

```go
// comparing value types
arr1 := [2]int{1, 2}
arr2 := [2]int{1, 2}
fmt.Println(arr1 == arr2) // output: true

// comparing simple reference types
dog1 := Dog{Name: "SuperHero"}
dog2 := Dog{Name: "SuperHero"}
fmt.Println(dog1 == dog2) // output: true
```

## What's next?

In the next part, we will talk about loops and logic flows. Stay tuned and I will see you in the next one.

**Please feel free to leave a comment below if you run into any problems or if you need a helping hand.**  
