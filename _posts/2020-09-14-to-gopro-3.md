---
title: Road to Go pro - Flow control
date: 2020-09-14 00:00:00
featured_image: 'https://storage.googleapis.com/songxue-dev-images/content-images/2020-09-14-road-go-pro-3/feature.jpg'
excerpt: 'Road to Go Pro is a series of short Go (the programming language) tutorials that take you from a beginner to a Pro. In this tutorial, we are going to talk about the flow control and pointers in Go.'
---

*A few words before we start.*
*You can find the code used in this tutorial in this [repository](https://github.com/songx23/RoadToGoPro).*  
*Also a special thanks to [Mark Hume-Cook](https://medium.com/@mhumecook) for reviewing this tutorial.*

## Flow control

We talked about the basic types and data structures in the last part of the tutorial. In this one, we will talk about the flow control.

### if

Firstly, let's look at the `if` statements. If and else statements are the most basic flow controls. It can control the program to execute different statements based on conditions. The syntax of if statement looks like this.

```go
// if statement
if condition {
   // if condition is met, program executes statements here
}
```

When condition in the if statement is true, then the code inside the bracket will execute. Apart from the if statements, there are also `else` and `else if` statements. In a combination of `if`, `else if` and `else` statements, the code execution order is from top to the bottom. That means the condition in `if` statement is always going to be checked first. On the other hand, `else` will always to checked last and it is used as a catch all block in the end.

```go
if conditionA {
    // when condition A is met, execute code here
}
// else if statements
else if conditionB {
    // when condition A is not met and condition B is met, execute code here
}
// else statements
else {
    // when condition A is not met and condition B is not met as well, execute code here
}
```

So what does condition look like in the if statement? Anything statement that returns a boolean value can be placed in the condition. Here is an example.

```go
// if...else... statement example
grocery := []string{"onion", "milk"}
if len(grocery) < 2 {
    fmt.Println("Are you sure you have included everything you need in the shopping list?")
} else if len(grocery) < 20 {
    fmt.Println("Looks good. Time to go to the supermarket.")
} else {
    fmt.Println("You have too many things in your shopping list.")
}
// output: Are you sure you have included everything you need in the shopping list.
```

You can also use the logic gates in the condition. There are three logic gates available, and (`&&`), or (`||`), not(`!`). You can chain basic conditions with logic gates to form complex conditions.

```go
// condition with logic gate
covidCaseLimit := 50
dailyNewCOVIDCases := 45
loc, _ := time.LoadLocation("Australia/Melbourne")
if dailyNewCOVIDCases < covidCaseLimit && time.Now().After(time.Date(2020, 9, 28, 0, 0, 0, 0, loc)) {
    fmt.Println("Starting to lift restrictions! :)")
} else {
    fmt.Println("Nope, still in lockdown :(")
}
// output: depends on when you run the program, go have a try yourself ;)
```

There is no limit on how many else if statements you can write in one if/else code block. Whereas for the benefit of readability, it is not recommended to have a long list of if/else statements. `switch` statement is the right choice to handle these scenarios. Before we get to it, I want to point out another special syntax of `if` statements in Go.  
Go accepts a short statement before the condition of if statement. This syntax is used for making the code more concise. It is widely used for error handling, which we will cover in later tutorials. Let's have a look at this syntax first.

```go
if location, err := time.LoadLocation("Mars/Somewhere"); err != nil {
    fmt.Println(err) // unknown time zone Mars/Somewhere
    fmt.Println("This is not a valid location on Earth.", " Default time zone:", location)
    // output: This is not a valid location on Earth.  Default time zone: UTC
}
// error if trying to print out location
fmt.Println(location) // undefined: location
```

You can add a declaration of one or more variables before stating the condition in `if` statement. The variables declared are only accessible in the condition and inside the `if` block. In the example above, if we try to access the variable in the short statement, we will get an error back. In that sense, this syntax helps us to declaring short-lived variable in the correct context. You will see why this is handy in the future.  

#### Variable scope

Since we touched on the accessibility of variables, let me explain what is the scope of a variable. No all variables are declared equally. Their accessibility depends on where they are declared. For instance, if a variable is declared inside an `if` block, it can only be accessed inside the same code block, not from outside. A general rule of thumb is: the reach of a variable is bounded with its closest `{}`.  

```go
// variable scopes
if _, err := time.LoadLocation("Mars/Somewhere"); err != nil {
    anotherPlace := "Asgard"
    fmt.Println("This is not a valid location on Earth. Choosing somewhere else... ", anotherPlace)
} else {
    newPlace := "New Asgard"
    fmt.Println(newPlace, " is a valid location on Earth.")
}
// errors as the variables are out of scope
fmt.Println(anotherPlace) // undefined: anotherPlace
fmt.Println(newPlace) // undefined: newPlace
```

As you can see in the example, `anotherPlace` and `newPlace` are only accessible within the closest brackets around them. If there's no bracket around a variable, then it is a global variable inside the package. We will discuss more on this point when we talk about packages. For now, the bracket rule is sufficient.

### switch

Alright, enough distractions. Let's get back to the flow control. I mentioned that when we have a long list of conditions, it's better to use the `switch` statement than the `if` statement. `switch` is a more concise form of `if`. It looks like this.

```go
// switch statement
numText := "one"
switch numText {
    case "one":
        fmt.Println(numText, " = ", 1)
    case "two":
        fmt.Println(numText, " = ", 2)
    default:
        fmt.Println(numText, " is not 1 or 2")
}
// output: one  =  1
```

This switch statement can be transformed to `if` statement and it will look like this.

```go
// transform switch to if
if numText == "one" {
    fmt.Println(numText, " = ", 1)
else if numText == "two"{
    fmt.Println(numText, " = ", 2)
} else {
    fmt.Println(numText, " is not 1 or 2")
}
```

By comparing the two equivalent code blocks, you can see that we were comparing the variable specified in the `switch` statement with the variables in the `case` statement. If we find a match, then execute the code inside that `case` block. After that, the program exits the entire switch block. The last `default` block is like the `else` statement, which is used to catch all other scenarios than specified above.  
You might not feel it is easier to write switch statement but imagine if you need to write 10 conditions like this. You will be glad that switch statement exists.  

`switch` also has a more generic form where we don't need to specify a variable to compare with. We can emit the variable in the statement and specify conditions in `case` statements instead. For instance,

```go
// generic switch statement
switch {
case "one" == "1":
    fmt.Println("This is impossible")
case dailyNewCOVIDCases < covidCaseLimit && time.Now().After(time.Date(2020, 9, 28, 0, 0, 0, 0, loc)):
    fmt.Println("Easing lockdown")
default:
    fmt.Println("Catching all other scenarios")
}
// output: depending on the time you execute the program, it can either be "Easing lockdown"
//  or "Catching all other scenarios"
```

Yes, case conditions in the generic switch statement doesn't need to be related, it can be any conditions that fits an `if` statement (excluding the special short statement syntax).  
So when should we use `if` and when should we use `switch`? In my opinion, they're inter-changeable in many cases. Personally, I will choose whichever brings more clarity visual-wise and uses lesser lines of code.

## Loop

### for

## Pointer