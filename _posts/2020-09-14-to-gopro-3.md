---
title: Road to Go pro - Flow control
date: 2020-09-14 00:00:00
featured_image: 'https://storage.googleapis.com/songxue-dev-images/content-images/2020-09-14-road-go-pro-3/feature.jpg'
excerpt: 'Road to Go Pro is a series of short Go (the programming language) tutorials that take you from a beginner to a Pro. In this tutorial, we are going to talk about the flow control and pointers in Go.'
---

*A few words before we start.*
*You can find the code used in this tutorial in this [repository](https://github.com/songx23/RoadToGoPro).*  
*Also a special thanks to [Mark Hume-Cook](https://medium.com/@mhumecook) for reviewing this tutorial.*

## Flow control

We talked about the basic types and data structures in the last part of the tutorial. In this one, we will talk about the flow control.

### if

Firstly, let's look at the `if` statements. If and else statements are the most basic flow controls. It can control the program to execute different statements based on conditions. The syntax of if statement looks like this.

```go
// if statement
if condition {
   // if condition is met, program executes statements here
}
```

When condition in the if statement is true, then the code inside the bracket will execute. Apart from the if statements, there are also `else` and `else if` statements. In a combination of `if`, `else if` and `else` statements, the code execution order is from top to the bottom. That means the condition in `if` statement is always going to be checked first. On the other hand, `else` will always to checked last and it is used as a catch all block in the end.

```go
if conditionA {
    // when condition A is met, execute code here
}
// else if statements
else if conditionB {
    // when condition A is not met and condition B is met, execute code here
}
// else statements
else {
    // when condition A is not met and condition B is not met as well, execute code here
}
```

So what does condition look like in the if statement? Anything statement that returns a boolean value can be placed in the condition. Here is an example.

```go
// if...else... statement example
grocery := []string{"onion", "milk"}
if len(grocery) < 2 {
    fmt.Println("Are you sure you have included everything you need in the shopping list?")
} else if len(grocery) < 20 {
    fmt.Println("Looks good. Time to go to the supermarket.")
} else {
    fmt.Println("You have too many things in your shopping list.")
}
// output: Are you sure you have included everything you need in the shopping list.
```

You can also use the logic gates in the condition. There are three logic gates available, and (`&&`), or (`||`), not(`!`). You can chain basic conditions with logic gates to form complex conditions.

```go
// condition with logic gate
covidCaseLimit := 50
dailyNewCOVIDCases := 45
loc, _ := time.LoadLocation("Australia/Melbourne")
if dailyNewCOVIDCases < covidCaseLimit && time.Now().After(time.Date(2020, 9, 28, 0, 0, 0, 0, loc)) {
    fmt.Println("Starting to lift restrictions! :)")
} else {
    fmt.Println("Nope, still in lockdown :(")
}
// output: depends on when you run the program, go have a try yourself ;)
```

There is no limit on how many else if statements you can write in one if/else code block. Whereas for the benefit of readability, it is not recommended to have a long list of if/else statements. `switch` statement is the right choice to handle these scenarios. Before we get to it, I want to point out another special syntax of `if` statements in Go.  
Go accepts a short statement before the condition of if statement. This syntax is used for making the code more concise. It is widely used for error handling, which we will cover in later tutorials. Let's have a look at this syntax first.

```go
if location, err := time.LoadLocation("Mars/Somewhere"); err != nil {
    fmt.Println(err) // unknown time zone Mars/Somewhere
    fmt.Println("This is not a valid location on Earth.", "Default time zone:", location)
    // output: This is not a valid location on Earth. Default time zone: UTC
}
// error if trying to print out location
fmt.Println(location) // undefined: location
```

You can add a declaration of one or more variables before stating the condition in `if` statement. The variables declared are only accessible in the condition and inside the `if` block. In the example above, if we try to access the variable in the short statement, we will get an error back. In that sense, this syntax helps us to declaring short-lived variable in the correct context. You will see why this is handy in the future.  

#### Variable scope

Since we touched on the accessibility of variables, let me explain what is the scope of a variable. No all variables are declared equally. Their accessibility depends on where they are declared. For instance, if a variable is declared inside an `if` block, it can only be accessed inside the same code block, not from outside. A general rule of thumb is: the reach of a variable is bounded with its closest `{}`.  

```go
// variable scopes
if _, err := time.LoadLocation("Mars/Somewhere"); err != nil {
    anotherPlace := "Asgard"
    fmt.Println("This is not a valid location on Earth. Choosing somewhere else...", anotherPlace)
} else {
    newPlace := "New Asgard"
    fmt.Println(newPlace, "is a valid location on Earth.")
}
// errors as the variables are out of scope
fmt.Println(anotherPlace) // undefined: anotherPlace
fmt.Println(newPlace) // undefined: newPlace
```

As you can see in the example, `anotherPlace` and `newPlace` are only accessible within the closest brackets around them. If there's no bracket around a variable, then it is a global variable inside the package. We will discuss more on this point when we talk about packages. For now, the bracket rule is sufficient.

### switch

Alright, enough distractions. Let's get back to the flow control. I mentioned that when we have a long list of conditions, it's better to use the `switch` statement than the `if` statement. `switch` is a more concise form of `if`. It looks like this.

```go
// switch statement
numText := "one"
switch numText {
    case "one":
        fmt.Println(numText, "=", 1)
    case "two":
        fmt.Println(numText, "=", 2)
    default:
        fmt.Println(numText, "is not 1 or 2")
}
// output: one = 1
```

This switch statement can be transformed to `if` statement and it will look like this.

```go
// transform switch to if
if numText == "one" {
    fmt.Println(numText, "=", 1)
else if numText == "two"{
    fmt.Println(numText, "=", 2)
} else {
    fmt.Println(numText, "is not 1 or 2")
}
```

By comparing the two equivalent code blocks, you can see that we were comparing the variable specified in the `switch` statement with the variables in the `case` statement. If we find a match, then execute the code inside that `case` block. After that, the program exits the entire switch block. The last `default` block is like the `else` statement, which is used to catch all other scenarios than specified above.  
You might not feel it is easier to write switch statement but imagine if you need to write 10 conditions like this. You will be glad that switch statement exists.  

`switch` also has a more generic form where we don't need to specify a variable to compare with. We can emit the variable in the statement and specify conditions in `case` statements instead. For instance,

```go
// generic switch statement
switch {
case "one" == "1":
    fmt.Println("This is impossible")
case dailyNewCOVIDCases < covidCaseLimit && time.Now().After(time.Date(2020, 9, 28, 0, 0, 0, 0, loc)):
    fmt.Println("Easing lockdown")
default:
    fmt.Println("Catching all other scenarios")
}
// output: depending on the time you execute the program, it can either be "Easing lockdown"
//  or "Catching all other scenarios"
```

Yes, case conditions in the generic switch statement doesn't need to be related, it can be any conditions that fits an `if` statement (excluding the special short statement syntax).  
So when should we use `if` and when should we use `switch`? In my opinion, they're inter-changeable in many cases. Personally, I will choose whichever brings more clarity visual-wise and uses lesser lines of code.

## Loop

When we need to execute logic repeatedly, loop is the best helper. Nobody wants to copy paste duplicated code over and over again. In other language, you've probably seen other types of loop such as `while`. But in Go, there is only one type of loop statement, which is `for`.

### for

For loop has four basic forms in Go.

#### Basic form

The most basic form of `for` loop looks exactly the same in many languages. Go sticked to the original form of `for` loop. For your information, I rarely use this basic form in real projects.  

```go
// for loop: basic
// import strings
lockdownLevels := []string{"stage1", "stage2", "stage3", "stage4"}
for i:=0; i < len(lockdownLevels); i++ {
    switch {
        case strings.Contains(lockdownLevels[i], "1"):
            fmt.Println("In", lockdownLevels[i], "lockdown. Life is great.")
        case strings.Contains(lockdownLevels[i], "2"):
            fmt.Println("In", lockdownLevels[i], "lockdown. Life is good.")
        case strings.Contains(lockdownLevels[i], "3"):
            fmt.Println("In", lockdownLevels[i], "lockdown. Life is not too bad.")
        case strings.Contains(lockdownLevels[i], "4"):
            fmt.Println("In", lockdownLevels[i], "lockdown. Life is not too good.")
        default:
            fmt.Println("Unknown lockdown stage")
    }
}
// output:
//  In stage1 lockdown. Life is great.
//  In stage2 lockdown. Life is good.
//  In stage3 lockdown. Life is not too bad.
//  In stage4 lockdown. Life is not too good.
```

Let's quickly go through the basic form syntax, just in case this looks alien to you.  
There are three short statements in the for loop above and they are separated by `;`s. The first short statement is the initiation part. It's used to initiate the loop index. Usually it starts with 0. The second short statement is the loop condition. As long as the loop condition is met, the loop will keep executing until the loop condition returns `false`. And the last statement is the stepping function. We specify what's going to change for each loop. Most of the time, it's doing to be increasing/decreasing the loop index. The example above shows us how can we loop through a slice. We start with setting the loop index to 0. The loop should exit after reaching the last element in the slice. Thus, we set the condition to "loop index needs to be smaller than the length of the slice". Lastly, we set the stepping function to "increase index by 1".  
To be noted, all these three short statements are optional. We will see the different implications below.

#### While form

While loop in Go is the first variant of the basic for loop. If we emit the initiation and stepping function from the basic form, we will get the while loop in Go. Therefore, as long as the loop condition is met, while loop will keep executing. The example above can be easily transformed to while loop like this.

```go
// for loop: while form
whileIndex := 0
for whileIndex < len(lockdownLevels) {
    switch {
    case strings.Contains(lockdownLevels[whileIndex], "1"):
        fmt.Println("In", lockdownLevels[whileIndex], "lockdown. Life is great.")
    case strings.Contains(lockdownLevels[whileIndex], "2"):
        fmt.Println("In", lockdownLevels[whileIndex], "lockdown. Life is good.")
    case strings.Contains(lockdownLevels[whileIndex], "3"):
        fmt.Println("In", lockdownLevels[whileIndex], "lockdown. Life is not too bad.")
    case strings.Contains(lockdownLevels[whileIndex], "4"):
        fmt.Println("In", lockdownLevels[whileIndex], "lockdown. Life is not too good.")
    default:
        fmt.Println("Unknown lockdown stage")
    }
    whileIndex++
}
// output: same as above
```

#### Endless form

Endless loop, also known as dead loop, is a dangerous operation. Normally, if we have a endless loop, it's going to break the program because it can never escape from the loop. Endless loop will devour all the resources it can get and crash the system. That's not a good thing. However, in Go, there are some special use cases where we actually need to use endless loop. For instance, when you want to run an async background process. It is very easy to create an endless loop, just emit all three statements in the basic form.

```go
go func() {
    for {
        fmt.Println("I'm an endless loop.")
        time.Sleep(1 * time.Second)
    }
}()

time.Sleep(5 * time.Second)
// output: 5 rows of I'm an endless loop.
```

Of course, I'm not going to break your computer by asking you to run an endless loop. What we are doing here is to run an endless loop in a goroutine (will be covered in future). Goroutine enables async processing, hence our endless loop runs in parallel of the main process. While the main process sleeps for 5 seconds, the async process should execute the loop continuously until the main process exits.  That's why we see "I'm an endless loop." printed for 5 times in the console.

#### Range operator

Last but not the least, let's talk about the range operator. The range operator helps to iterate over types like slices/arrays, maps, channels and strings. Let's see how we can simplify the basic form loop.

```go
// for loop: range operator over slice/array
for index, value := range lockdownLevels {
    fmt.Print("Index ", index, ": ")
    switch {
    case strings.Contains(value, "1"):
        fmt.Println("In", value, "lockdown. Life is great.")
    case strings.Contains(value, "2"):
        fmt.Println("In", value, "lockdown. Life is good.")
    case strings.Contains(value, "3"):
        fmt.Println("In", value, "lockdown. Life is not too bad.")
    case strings.Contains(value, "4"):
        fmt.Println("In", value, "lockdown. Life is not too good.")
    default:
        fmt.Println("Unknown lockdown stage")
    }
}
// output:
//  Index 0: In stage1 lockdown. Life is great.
//  Index 1: In stage2 lockdown. Life is good.
//  Index 2: In stage3 lockdown. Life is not too bad.
//  Index 3: In stage4 lockdown. Life is not too good.
```

When applying range operator on a slice or an array, it provides two variables for each iteration, namely the index and value of current iteration. Note that these variables are short-lived and scoped to the for loop block. We can only access them inside the loop. Usually, we don't need the index, so we can emit assigning a variable by using `_`. It will look like this `for _, value : range slice {...}`. In fact, if you don't use either of the variable inside the loop, Go will force you to emit them.  
Iterating through a map using range operator also returns two variables. Except in map, range operator returns keys instead of indexes.

```go
// for loop: range operator over map
postcodes := map[int]string{
    3000: "Melbourne",
    2000: "Sydney",
    6000: "Perth",
}
for key, value := range postcodes {
    fmt.Println("Postcode:", key, "Name:", value)
}
// output:
//  Postcode: 2000 Name: Sydney
//  Postcode: 6000 Name: Perth
//  Postcode: 3000 Name: Melbourne
```

Similarly, we need to emit any variables returned by range operator if we don't use them.  
Range operator again returns two variables when applied on a string, or String type. The first one is the same as slice/array, which is indexes. The second one is the unicode (represented by int32) of the character.  

```go
// for loop: range operator over string
helloString := "Hello!"
for _, u := range helloString {
    // using fmt package to format the output
    fmt.Printf("Unicode: %U; Character: %c", u, u)
}
// output:
//  Unicode: U+0048; Character: H
//  Unicode: U+0065; Character: e
//  Unicode: U+006C; Character: l
//  Unicode: U+006C; Character: l
//  Unicode: U+006F; Character: o
//  Unicode: U+0021; Character: !
```

In this example, you can see that we used a new function from the fmt package. It's time to explain the powerful formatting capabilities of the fmt package. You can go to the last section of this tutorial first to have a sneak peek.

Lastly, looping through channel type is a bit advance at this stage. We will cover that later when we touch more on goroutines and asynchronous processing.  

#### continue & break

`continue` and `break` are the short-circuit statements for skipping iterations. When we use continue, the program will skip the code execution after `continue` and start the next iteration. While `break` is more forceful, the program will skip the entire loop when it sees break.

```go
// continue
for key, value := range postcodes {
    if key == 6000 {
        continue // skip the following code for current iteration
    }
    fmt.Printf("Postcode: %d Name: %s\n", key, value)
}
// output:
//  Postcode: 2000 Name: Sydney
//  Postcode: 3000 Name: Melbourne

// break
for key, value := range postcodes {
    if key == 6000 {
        break // skip the entire loop
    }
    fmt.Printf("Postcode: %d Name: %s\n", key, value)
}
// output:
//  Postcode: 2000 Name: Sydney
```

#### goto & label

#### defer

## fmt package
