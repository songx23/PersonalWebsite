---
title: Road to Go pro - Flow control
date: 2020-09-14 00:00:00
featured_image: 'https://storage.googleapis.com/songxue-dev-images/content-images/2020-09-14-road-go-pro-3/feature.jpg'
excerpt: 'Road to Go Pro is a series of short Go (the programming language) tutorials that take you from a beginner to a Pro. In this tutorial, we are going to talk about the flow control and pointers in Go.'
---

*A few words before we start.*
*You can find the code used in this tutorial in this [repository](https://github.com/songx23/RoadToGoPro).*  
*Also a special thanks to [Mark Hume-Cook](https://medium.com/@mhumecook) for reviewing this tutorial.*

## Flow control

We talked about the basic types and data structures in the last part of the tutorial. In this one, we will talk about the flow control.

### if

Firstly, let's look at the `if` statements. If and else statements are the most basic flow controls. It can control the program to execute different statements based on conditions. The syntax of if statement looks like this.

```go
// if statement
if condition {
   // if condition is met, program executes statements here
}
```

When condition in the if statement is true, then the code inside the bracket will execute. Apart from the if statements, there are also `else` and `else if` statements. In a combination of `if`, `else if` and `else` statements, the code execution order is from top to the bottom. That means the condition in `if` statement is always going to be checked first. On the other hand, `else` will always to checked last and it is used as a catch all block in the end.

```go
if conditionA {
    // when condition A is met, execute code here
}
// else if statements
else if conditionB {
    // when condition A is not met and condition B is met, execute code here
}
// else statements
else {
    // when condition A is not met and condition B is not met as well, execute code here
}
```

So what does condition look like in the if statement? Anything statement that returns a boolean value can be placed in the condition. Here is an example.

```go
// if...else... statement example
grocery := []string{"onion", "milk"}
if len(grocery) < 2 {
    fmt.Println("Are you sure you have included everything you need in the shopping list?")
} else if len(grocery) < 20 {
    fmt.Println("Looks good. Time to go to the supermarket.")
} else {
    fmt.Println("You have too many things in your shopping list.")
}
// output: Are you sure you have included everything you need in the shopping list.
```

You can also use the logic gates in the condition. There are three logic gates available, and (`&&`), or (`||`), not(`!`). You can chain basic conditions with logic gates to form complex conditions.

```go
// condition with logic gate
covidCaseLimit := 50
dailyNewCOVIDCases := 45
loc, _ := time.LoadLocation("Australia/Melbourne")
if dailyNewCOVIDCases < covidCaseLimit && time.Now().After(time.Date(2020, 9, 28, 0, 0, 0, 0, loc)) {
    fmt.Println("Starting to lift restrictions! :)")
} else {
    fmt.Println("Nope, still in lockdown :(")
}
// output: depends on when you run the program, go have a try yourself ;)
```

There is no limit on how many else if statements you can write in one if/else code block. Whereas for the benefit of readability, it is not recommended to have a long list of if/else statements. `switch` statement is the right choice to handle these scenarios. Before we get to it, I want to point out another special syntax of `if` statements in Go.  
Go accepts a short statement before the condition of if statement. This syntax is used for making the code more concise. It is widely used for error handling, which we will cover in later tutorials. Let's have a look at this syntax first.

```go
if location, err := time.LoadLocation("Mars/Somewhere"); err != nil {
    fmt.Println(err) // unknown time zone Mars/Somewhere
    fmt.Println("This is not a valid location on Earth.", "Default time zone:", location)
    // output: This is not a valid location on Earth. Default time zone: UTC
}
// error if trying to print out location
fmt.Println(location) // undefined: location
```

You can add a declaration of one or more variables before stating the condition in `if` statement. The variables declared are only accessible in the condition and inside the `if` block. In the example above, if we try to access the variable in the short statement, we will get an error back. In that sense, this syntax helps us to declaring short-lived variable in the correct context. You will see why this is handy in the future.  

#### Variable scope

Since we touched on the accessibility of variables, let me explain what is the scope of a variable. No all variables are declared equally. Their accessibility depends on where they are declared. For instance, if a variable is declared inside an `if` block, it can only be accessed inside the same code block, not from outside. A general rule of thumb is: the reach of a variable is bounded with its closest `{}`.  

```go
// variable scopes
if _, err := time.LoadLocation("Mars/Somewhere"); err != nil {
    anotherPlace := "Asgard"
    fmt.Println("This is not a valid location on Earth. Choosing somewhere else...", anotherPlace)
} else {
    newPlace := "New Asgard"
    fmt.Println(newPlace, "is a valid location on Earth.")
}
// errors as the variables are out of scope
fmt.Println(anotherPlace) // undefined: anotherPlace
fmt.Println(newPlace) // undefined: newPlace
```

As you can see in the example, `anotherPlace` and `newPlace` are only accessible within the closest brackets around them. If there's no bracket around a variable, then it is a global variable inside the package. We will discuss more on this point when we talk about packages. For now, the bracket rule is sufficient.

### switch

Alright, enough distractions. Let's get back to the flow control. I mentioned that when we have a long list of conditions, it's better to use the `switch` statement than the `if` statement. `switch` is a more concise form of `if`. It looks like this.

```go
// switch statement
numText := "one"
switch numText {
    case "one":
        fmt.Println(numText, "=", 1)
    case "two":
        fmt.Println(numText, "=", 2)
    default:
        fmt.Println(numText, "is not 1 or 2")
}
// output: one = 1
```

This switch statement can be transformed to `if` statement and it will look like this.

```go
// transform switch to if
if numText == "one" {
    fmt.Println(numText, "=", 1)
else if numText == "two"{
    fmt.Println(numText, "=", 2)
} else {
    fmt.Println(numText, "is not 1 or 2")
}
```

By comparing the two equivalent code blocks, you can see that we were comparing the variable specified in the `switch` statement with the variables in the `case` statement. If we find a match, then execute the code inside that `case` block. After that, the program exits the entire switch block. The last `default` block is like the `else` statement, which is used to catch all other scenarios than specified above.  
You might not feel it is easier to write switch statement but imagine if you need to write 10 conditions like this. You will be glad that switch statement exists.  

`switch` also has a more generic form where we don't need to specify a variable to compare with. We can emit the variable in the statement and specify conditions in `case` statements instead. For instance,

```go
// generic switch statement
switch {
case "one" == "1":
    fmt.Println("This is impossible")
case dailyNewCOVIDCases < covidCaseLimit && time.Now().After(time.Date(2020, 9, 28, 0, 0, 0, 0, loc)):
    fmt.Println("Easing lockdown")
default:
    fmt.Println("Catching all other scenarios")
}
// output: depending on the time you execute the program, it can either be "Easing lockdown"
//  or "Catching all other scenarios"
```

Yes, case conditions in the generic switch statement doesn't need to be related, it can be any conditions that fits an `if` statement (excluding the special short statement syntax).  
So when should we use `if` and when should we use `switch`? In my opinion, they're inter-changeable in many cases. Personally, I will choose whichever brings more clarity visual-wise and uses lesser lines of code.

## Loop

When we need to execute logic repeatedly, loop is the best helper. Nobody wants to copy paste duplicated code over and over again. In other language, you've probably seen other types of loop such as `while`. But in Go, there is only one type of loop statement, which is `for`.

### for

For loop has four basic forms in Go.

#### Basic form

The most basic form of `for` loop looks exactly the same in many languages. Go sticked to the original form of `for` loop. For your information, I rarely use this basic form in real projects.  

```go
// for loop: basic
// import strings
lockdownLevels := []string{"stage1", "stage2", "stage3", "stage4"}
for i:=0; i < len(lockdownLevels); i++ {
    switch {
        case strings.Contains(lockdownLevels[i], "1"):
            fmt.Println("In", lockdownLevels[i], "lockdown. Life is great.")
        case strings.Contains(lockdownLevels[i], "2"):
            fmt.Println("In", lockdownLevels[i], "lockdown. Life is good.")
        case strings.Contains(lockdownLevels[i], "3"):
            fmt.Println("In", lockdownLevels[i], "lockdown. Life is not too bad.")
        case strings.Contains(lockdownLevels[i], "4"):
            fmt.Println("In", lockdownLevels[i], "lockdown. Life is not too good.")
        default:
            fmt.Println("Unknown lockdown stage")
    }
}
// output:
//  In stage1 lockdown. Life is great.
//  In stage2 lockdown. Life is good.
//  In stage3 lockdown. Life is not too bad.
//  In stage4 lockdown. Life is not too good.
```

Let's quickly go through the basic form syntax, just in case this looks alien to you.  
There are three short statements in the for loop above and they are separated by `;`s. The first short statement is the initiation part. It's used to initiate the loop index. Usually it starts with 0. The second short statement is the loop condition. As long as the loop condition is met, the loop will keep executing until the loop condition returns `false`. And the last statement is the stepping function. We specify what's going to change for each loop. Most of the time, it's doing to be increasing/decreasing the loop index. The example above shows us how can we loop through a slice. We start with setting the loop index to 0. The loop should exit after reaching the last element in the slice. Thus, we set the condition to "loop index needs to be smaller than the length of the slice". Lastly, we set the stepping function to "increase index by 1".  
To be noted, all these three short statements are optional. We will see the different implications below.

#### While form

While loop in Go is the first variant of the basic for loop. If we emit the initiation and stepping function from the basic form, we will get the while loop in Go. Therefore, as long as the loop condition is met, while loop will keep executing. The example above can be easily transformed to while loop like this.

```go
// for loop: while form
whileIndex := 0
for whileIndex < len(lockdownLevels) {
    switch {
    case strings.Contains(lockdownLevels[whileIndex], "1"):
        fmt.Println("In", lockdownLevels[whileIndex], "lockdown. Life is great.")
    case strings.Contains(lockdownLevels[whileIndex], "2"):
        fmt.Println("In", lockdownLevels[whileIndex], "lockdown. Life is good.")
    case strings.Contains(lockdownLevels[whileIndex], "3"):
        fmt.Println("In", lockdownLevels[whileIndex], "lockdown. Life is not too bad.")
    case strings.Contains(lockdownLevels[whileIndex], "4"):
        fmt.Println("In", lockdownLevels[whileIndex], "lockdown. Life is not too good.")
    default:
        fmt.Println("Unknown lockdown stage")
    }
    whileIndex++
}
// output: same as above
```

#### Endless form

Endless loop, also known as dead loop, is a dangerous operation. Normally, if we have a endless loop, it's going to break the program because it can never escape from the loop. Endless loop will devour all the resources it can get and crash the system. That's not a good thing. However, in Go, there are some special use cases where we actually need to use endless loop. For instance, when you want to run an async background process. It is very easy to create an endless loop, just emit all three statements in the basic form.

```go
go func() {
    for {
        fmt.Println("I'm an endless loop.")
        time.Sleep(1 * time.Second)
    }
}()

time.Sleep(5 * time.Second)
// output: 5 rows of I'm an endless loop.
```

Of course, I'm not going to break your computer by asking you to run an endless loop. What we are doing here is to run an endless loop in a goroutine (will be covered in future). Goroutine enables async processing, hence our endless loop runs in parallel of the main process. While the main process sleeps for 5 seconds, the async process should execute the loop continuously until the main process exits.  That's why we see "I'm an endless loop." printed for 5 times in the console.

#### Range operator

Last but not the least, let's talk about the range operator. The range operator helps to iterate over types like slices/arrays, maps, channels and strings. Let's see how we can simplify the basic form loop.

```go
// for loop: range operator over slice/array
for index, value := range lockdownLevels {
    fmt.Print("Index ", index, ": ")
    switch {
    case strings.Contains(value, "1"):
        fmt.Println("In", value, "lockdown. Life is great.")
    case strings.Contains(value, "2"):
        fmt.Println("In", value, "lockdown. Life is good.")
    case strings.Contains(value, "3"):
        fmt.Println("In", value, "lockdown. Life is not too bad.")
    case strings.Contains(value, "4"):
        fmt.Println("In", value, "lockdown. Life is not too good.")
    default:
        fmt.Println("Unknown lockdown stage")
    }
}
// output:
//  Index 0: In stage1 lockdown. Life is great.
//  Index 1: In stage2 lockdown. Life is good.
//  Index 2: In stage3 lockdown. Life is not too bad.
//  Index 3: In stage4 lockdown. Life is not too good.
```

When applying range operator on a slice or an array, it provides two variables for each iteration, namely the index and value of current iteration. Note that these variables are short-lived and scoped to the for loop block. We can only access them inside the loop. Usually, we don't need the index, so we can emit assigning a variable by using `_`. It will look like this `for _, value : range slice {...}`. In fact, if you don't use either of the variable inside the loop, Go will force you to emit them.  
Iterating through a map using range operator also returns two variables. Except in map, range operator returns keys instead of indexes.

```go
// for loop: range operator over map
postcodes := map[int]string{
    3000: "Melbourne",
    2000: "Sydney",
    6000: "Perth",
}
for key, value := range postcodes {
    fmt.Println("Postcode:", key, "Name:", value)
}
// output:
//  Postcode: 2000 Name: Sydney
//  Postcode: 6000 Name: Perth
//  Postcode: 3000 Name: Melbourne
```

Similarly, we need to emit any variables returned by range operator if we don't use them.  
Range operator again returns two variables when applied on a string, or String type. The first one is the same as slice/array, which is indexes. The second one is the unicode (represented by int32) of the character.  

```go
// for loop: range operator over string
helloString := "Hello!"
for _, u := range helloString {
    // using fmt package to format the output
    fmt.Printf("Unicode: %U; Character: %c", u, u)
}
// output:
//  Unicode: U+0048; Character: H
//  Unicode: U+0065; Character: e
//  Unicode: U+006C; Character: l
//  Unicode: U+006C; Character: l
//  Unicode: U+006F; Character: o
//  Unicode: U+0021; Character: !
```

In this example, you can see that we used a new function from the fmt package. It's time to explain the powerful formatting capabilities of the fmt package. You can go to the last section of this tutorial first to have a sneak peek.

Lastly, looping through channel type is a bit advance at this stage. We will cover that later when we touch more on goroutines and asynchronous processing.  

#### continue & break

`continue` and `break` are the short-circuit statements for skipping iterations. When we use continue, the program will skip the code execution after `continue` and start the next iteration. While `break` is more forceful, the program will skip the entire loop when it sees break.

```go
// continue
for key, value := range postcodes {
    if key == 6000 {
        continue // skip the following code for current iteration
    }
    fmt.Printf("Postcode: %d Name: %s\n", key, value)
}
// output:
//  Postcode: 2000 Name: Sydney
//  Postcode: 3000 Name: Melbourne

// break
for key, value := range postcodes {
    if key == 6000 {
        break // skip the entire loop
    }
    fmt.Printf("Postcode: %d Name: %s\n", key, value)
}
// output:
//  Postcode: 2000 Name: Sydney
```

#### goto & label

`goto` and `label` provide a jump from a `goto` statement to `label` in the same function. If you have a background of other programming languages like Java and C#, you will find that they are the same in Go. The convention of label name is to use all capital letters.  

```go
// goto & label
    fmt.Println("First line of code.")
    goto SKIP;
    fmt.Println("Second line of code.") // this line is skipped
SKIP: fmt.Println("Third line of code.")
// output:
//  First line of code.
//  Third line of code.
```

#### defer

`defer` is the last flow control statement I want to introduce in this tutorial. It is used for deferring function execution until the closest surrounding function exits. Here is an example of defer.

```go
// defer
dText := "defer #1"
defer fmt.Println(dText)
dText = "defer #2"
defer fmt.Println(dText)
// do something else
dText = "not deferred"
fmt.Println(dText)
// output:
//  not deferred
//  defer #2
//  defer #1
```

As shown in the example, the statements after defer were executed in the end when we exit the main function. To be noted that the execution sequence of a series of defer statements is reversed. In other words, the last stated defer will execute first when exiting the function. Also, the arguments inside defer statements are evaluated inline. That is the only thing which is not evaluated in the end.  
`defer` is useful when we create something that needs to be closed or removed by the end of a function. Without `defer`, we need to write an open statement in the beginning and then close it in the end. This is error-prone as we might forget to close it. With `defer`, we can write a `defer close()` statement right after opening. That way, it's less likely to forget. We will use it when touching on database connection, http servers in the advanced topics.

## Bonus content: fmt package

I'm sure by now, you are quite familiar with `fmt.Println` function. We used it a lot to print results in the console along the way. `fmt` is a built-in package of Go. It is a very powerful formatting library. `Println` is one of the easiest functions in the package. You can find the documentation of the fmt package [here](https://golang.org/pkg/fmt/). You can see there are quite a few contents there. I'm not going to go through them one by one in this tutorial. What I want to point out is the formatter in this package. Using formatter can save us time and lines of code when manipulating strings.  
So how do we use the formatter? You will find in that package, some of the functions have a trailing "f" in the name. This is the indication of those functions accept formatter as parameters. Let's use `Printf` as an example.  

```go
// basic usage of formatter
whoami := "formatter"
fmt.Printf("Hello, I'm your helpful %s\n", whoami)
// output: Hello, I'm your helpful formatter
```

The first parameter in `Printf` is the format string and the following parameter(s) are the arguments that will replace the format 'verbs'. You can see in the example above, format verb `%s` is replaced by the `whoami` value. You can place as many arguments as you want after the format string. However, the only requirement is that the number of format verbs needs to match with the number of arguments.  
The powerful core of formatter lies in the format verbs, let's check out different types of format verbs below, if you want to see the full list of format verbs, you can find them in the documentation of fmt package.  

### Booleans

The only available format verb for boolean is `%t`, it will format the boolean value to string value ("true" or "false").

```go
// format verbs: boolean
booleanTrue := true
fmt.Printf("Boolean in text: %t\n", booleanTrue) // output: Boolean in text: true
```

### Numbers

Numbers have more available format verbs. Let's see some of mostly used ones.

1. `%b`: base 2 number
2. `%d`: base 10 number
3. `%U`: Unicode format
4. `%e`/`%E`: scientific notation
5. `%f`: decimal point number

Let's see them in action.

```go
// format verbs: numbers
smallInt := 111
smallFloat := 111.11
largeFloat := 111111111111111.0
fmt.Printf(`Binary number: %b
Base 10 number: %d
Unicode: %U
Decimal point: %f
Scientific notationL %e
`, smallInt, smallInt, smallInt, smallFloat, largeFloat)
// output:
//  Binary number: 1101111
//  Base 10 number: 111
//  Unicode: U+006F
//  Decimal point: 111.110000
//  Scientific notationL 1.111111e+14
```

*Note: the format string wrapped with backticks are the same as normal double quotes. However, backtick allows writing a single string in multiple lines.

### Strings

Format verbs for strings:

1. `%s`: string
2. `%q`: string wrapped with double quotes, safely escaped

```go
// format verbs: string
simpleString := "I am a happy formatter"
quotedString := `"I am a happy double quoted formatter"`
fmt.Printf(`Plain string: %s
Quoted string: %q
Safely escaped quoted string: %q
`, simpleString, simpleString, quotedString)
// output:
//  Plain string: I am a happy formatter
//  Quoted string: "I am a happy formatter"
//  Safely escaped quoted string: "\"I am a happy double quoted formatter\""
```

### General

Last but not the least, let's check out some format verbs for general values.

1. `%v`: value in default format
2. `%+v`: prints field names when value is a struct
3. `%#v`: prints Go-syntax representation of the value

```go
// format verbs: general
simpleSlice := []string{"1", "2", "3", "Go"}
simpleMap := map[string]string{
    "%v":  "value in default format",
    "%+v": "value + field names",
}
simpleStruct := Person{
    Name:   "TesterUser",
    Gender: "Secret",
    DoB:    time.Date(1970, 1, 1, 0, 0, 0, 0, loc),
    Age:    50,
    Hobby:  []string{"Go", "Programming", "Break stuff", "Push buttons"},
}
fmt.Printf(`Default format of slice: %v
Default format of map: %v
Default format of struct: %v
struct with field names: %+v
Go-syntax representation of slice: %#v
Go-syntax representation of map: %#v
Go-syntax representation of struct: %#v
`, simpleSlice, simpleMap, simpleStruct, simpleStruct, simpleSlice, simpleMap, simpleStruct)
// output:
//  Default format of slice: [1 2 3 Go]
//  Default format of map: map[%+v:value + field names %v:value in default format]
//  Default format of struct: {TesterUser Secret 1970-01-01 00:00:00 +1000 AEST 50 [Go Programming Break stuff Push buttons]}
//  struct with field names: {Name:TesterUser Gender:Secret DoB:1970-01-01 00:00:00 +1000 AEST Age:50 Hobby:[Go Programming Break stuff Push buttons]}
//  Go-syntax representation of slice: []string{"1", "2", "3", "Go"}
//  Go-syntax representation of map: map[string]string{"%+v":"value + field names", "%v":"value in default format"}
//  Go-syntax representation of struct: main.Person{Name:"TesterUser", Gender:"Secret", DoB:time.Time{wall:0x0, ext:62135560800, loc:(*time.Location)(0xc0000261e0)}, Age:50, Hobby:[]string{"Go", "Programming", "Break stuff", "Push buttons"}}
```

That's pretty powerful right? More often, we don't really need to print out strings in the console. We only need to format strings as use them in the program. Luckily, there's another function called `Sprintf`. It's the same as `Printf`, the only difference is `Sprintf` doesn't print strings in the console, instead it returns formatted string back.  

## What's next?

In the next tutorial, we will talk about pointers and functions. Stay tuned and I will see you in the next one.

**Please feel free to leave a comment below if you run into any problems or if you need a helping hand. Feedbacks are always welcomed. Thank you for reading!**  
